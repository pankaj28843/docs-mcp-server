{% extends "base.html" %}

{% block title %}Docs MCP Dashboard{% endblock %}

{% block content %}
      <header class="flex flex-wrap items-center justify-between gap-4 mb-8">
        <div>
          <p class="text-xs uppercase tracking-widest text-slate-400">Docs MCP</p>
          <h1 class="text-3xl font-semibold">Tenant Crawl Dashboard</h1>
          <p class="text-sm text-slate-400">Last refresh: <span id="last-refresh">n/a</span></p>
        </div>
        <div class="flex flex-wrap items-center gap-3">
          <label class="text-xs uppercase tracking-widest text-slate-400" for="tenant-select">Focus</label>
          <input
            id="tenant-filter"
            placeholder="Filter tenants..."
            class="bg-slate-900 border border-slate-700 rounded px-3 py-2 text-sm"
          />
          <select id="tenant-select" class="bg-slate-900 border border-slate-700 rounded px-3 py-2 text-sm"></select>
          <button id="go-tenant" class="bg-slate-800 hover:bg-slate-700 text-slate-100 font-semibold px-3 py-2 rounded text-sm">
            Go
          </button>
          <button id="trigger-sync" class="bg-emerald-500 hover:bg-emerald-400 text-slate-900 font-semibold px-3 py-2 rounded text-sm">
            Trigger sync
          </button>
          <button id="force-sync" class="bg-amber-400 hover:bg-amber-300 text-slate-900 font-semibold px-3 py-2 rounded text-sm">
            Force sync
          </button>
          <button id="retry-failed" class="bg-rose-300 hover:bg-rose-200 text-slate-900 font-semibold px-3 py-2 rounded text-sm">
            Retry failed
          </button>
          <button id="trigger-index" class="bg-indigo-400 hover:bg-indigo-300 text-slate-900 font-semibold px-3 py-2 rounded text-sm">
            Reindex
          </button>
          <button id="refresh-now" class="bg-cyan-500 hover:bg-cyan-400 text-slate-900 font-semibold px-4 py-2 rounded text-sm">
            Refresh
          </button>
        </div>
      </header>

      <section class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4 mb-8">
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <p class="text-xs text-slate-400 uppercase">Tenants</p>
          <p id="metric-tenants" class="text-2xl font-semibold">n/a</p>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <p class="text-xs text-slate-400 uppercase">Tracked URLs</p>
          <p id="metric-urls" class="text-2xl font-semibold">n/a</p>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <p class="text-xs text-slate-400 uppercase">Success</p>
          <p id="metric-success" class="text-2xl font-semibold">n/a</p>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <p class="text-xs text-slate-400 uppercase">Failures</p>
          <p id="metric-fail" class="text-2xl font-semibold">n/a</p>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <p class="text-xs text-slate-400 uppercase">Indexed Docs</p>
          <p id="metric-indexed" class="text-2xl font-semibold">n/a</p>
        </div>
      </section>

      <section class="grid grid-cols-1 xl:grid-cols-2 gap-6 mb-8">
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <h2 class="text-sm uppercase tracking-widest text-slate-400 mb-3">Overall Status</h2>
          <div class="relative h-56 md:h-64 xl:h-72 2xl:h-80">
            <canvas id="summaryChart" class="w-full h-full"></canvas>
          </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <h2 class="text-sm uppercase tracking-widest text-slate-400 mb-3">Queue Depth by Tenant</h2>
          <div class="relative h-56 md:h-64 xl:h-72 2xl:h-80">
            <canvas id="queueChart" class="w-full h-full"></canvas>
          </div>
        </div>
      </section>

      <section class="grid grid-cols-1 xl:grid-cols-3 gap-6 mb-8">
        <div class="xl:col-span-2 bg-slate-900 border border-slate-800 rounded-xl p-4">
          <h2 class="text-sm uppercase tracking-widest text-slate-400 mb-3">Focused Tenant</h2>
          <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
            <div>
              <p class="text-xs text-slate-400 uppercase">Queue</p>
              <p id="tenant-queue" class="text-xl font-semibold">n/a</p>
            </div>
            <div>
              <p class="text-xs text-slate-400 uppercase">Success</p>
              <p id="tenant-success" class="text-xl font-semibold">n/a</p>
            </div>
            <div>
              <p class="text-xs text-slate-400 uppercase">Failures</p>
              <p id="tenant-fail" class="text-xl font-semibold">n/a</p>
            </div>
            <div>
              <p class="text-xs text-slate-400 uppercase">Indexed Docs</p>
              <p id="tenant-indexed" class="text-xl font-semibold">n/a</p>
            </div>
            <div>
              <p class="text-xs text-slate-400 uppercase">Last Indexed</p>
              <p id="tenant-indexed-at" class="text-sm text-slate-300">n/a</p>
            </div>
          </div>
          <div class="relative h-56 md:h-64 xl:h-72 2xl:h-80">
            <canvas id="tenantChart" class="w-full h-full"></canvas>
          </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 rounded-xl p-4">
          <h2 class="text-sm uppercase tracking-widest text-slate-400 mb-3">Tenants</h2>
          <div class="overflow-auto max-h-[28rem]">
            <table class="w-full text-sm min-w-full">
              <thead class="text-xs uppercase text-slate-500">
                <tr>
                  <th class="text-left pb-2">Tenant</th>
                  <th class="text-right pb-2">Queue</th>
                  <th class="text-right pb-2">Success</th>
                  <th class="text-right pb-2">Fail</th>
                  <th class="text-right pb-2">Indexed</th>
                </tr>
              </thead>
              <tbody id="tenant-rows" class="divide-y divide-slate-800"></tbody>
            </table>
          </div>
        </div>
      </section>

      <footer class="text-xs text-slate-500">Powered by /tenants/status and /{tenant}/sync/status</footer>
{% endblock %}

{% block body_scripts %}
    <script>
      const TENANTS = {{ tenant_codenames | tojson }};
      const ALLOWED = new Set(TENANTS);
      const summaryUrl = "/tenants/status";
      const tenantUrl = (tenant) => `/${tenant}/sync/status`;
      const tenantDashboardUrl = (tenant) => `/dashboard/${tenant}`;
      const triggerUrl = (tenant, force) =>
        `/${tenant}/sync/trigger?force_crawler=${force}&force_full_sync=${force}`;
      const indexTriggerUrl = (tenant, force) => `/${tenant}/index/trigger?force=${force}`;
      const retryFailedUrl = (tenant) => `/${tenant}/sync/retry-failed`;

      const byId = (id) => document.getElementById(id);
      const fmt = (value) => (Number.isFinite(value) ? value.toLocaleString() : "n/a");
      const parseNumber = (value) => (Number.isFinite(Number(value)) ? Number(value) : 0);

      const tenantSelect = byId("tenant-select");
      const tenantFilter = byId("tenant-filter");
      const tenantHistory = [];
      const maxHistory = 60;
      const allTenants = [...TENANTS];
      const urlParams = new URLSearchParams(window.location.search);
      const dateFns = window.dateFns;

      function toDate(value) {
        if (!value) return null;
        if (value instanceof Date) return value;
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }

      function formatLocalTime(value) {
        const date = toDate(value);
        if (!date) return "n/a";
        if (dateFns && dateFns.format) {
          return dateFns.format(date, "h:mm a");
        }
        return date.toLocaleTimeString();
      }

      function formatAge(value) {
        const date = toDate(value);
        if (!date) return "";
        const deltaSeconds = Math.max(0, Math.floor((Date.now() - date.getTime()) / 1000));
        if (deltaSeconds < 30) return "just now";
        if (deltaSeconds < 60) return "1m ago";
        const minutes = Math.floor(deltaSeconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        const days = Math.floor(hours / 24);
        if (days < 30) return `${days}d ago`;
        const months = Math.floor(days / 30);
        if (months < 12) return `${months}mo ago`;
        const years = Math.floor(months / 12);
        return `${years}y ago`;
      }

      function formatTimestamp(value) {
        const base = formatLocalTime(value);
        const age = formatAge(value);
        return age ? `${base} Â· ${age}` : base;
      }

      function setText(id, value) {
        byId(id).textContent = value;
      }

      function updateLastRefresh() {
        const now = new Date();
        setText("last-refresh", formatTimestamp(now));
      }

      function renderTenantSelect(tenantList, selected) {
        tenantSelect.innerHTML = "";
        tenantList.forEach((tenant) => {
          const option = document.createElement("option");
          option.value = tenant;
          option.textContent = tenant;
          tenantSelect.appendChild(option);
        });
        if (tenantList.length > 0) {
          tenantSelect.value = tenantList.includes(selected) ? selected : tenantList[0];
        }
      }

      const initialFilter = urlParams.get("filter") || "";
      const initialFocus = urlParams.get("focus") || allTenants[0] || "";
      tenantFilter.value = initialFilter;
      renderTenantSelect(
        initialFilter
          ? allTenants.filter((tenant) => tenant.toLowerCase().includes(initialFilter.toLowerCase()))
          : allTenants,
        initialFocus,
      );

      let summaryChart;
      let queueChart;
      let tenantChart;

      function initCharts() {
        const summaryCtx = byId("summaryChart").getContext("2d");
        summaryChart = new Chart(summaryCtx, {
          type: "doughnut",
          data: {
            labels: ["Success", "Pending", "Failed"],
            datasets: [
              {
                data: [0, 0, 0],
                backgroundColor: ["#22d3ee", "#f59e0b", "#f43f5e"],
                borderWidth: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#cbd5f5" } },
            },
          },
        });

        const queueCtx = byId("queueChart").getContext("2d");
        queueChart = new Chart(queueCtx, {
          type: "bar",
          data: {
            labels: [],
            datasets: [{ label: "Queue", data: [], backgroundColor: "#38bdf8" }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: "y",
            plugins: { legend: { labels: { color: "#cbd5f5" } } },
            scales: {
              x: { ticks: { color: "#94a3b8" } },
              y: { ticks: { color: "#94a3b8" } },
            },
          },
        });

        const tenantCtx = byId("tenantChart").getContext("2d");
        tenantChart = new Chart(tenantCtx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Queue Depth",
                data: [],
                borderColor: "#22d3ee",
                tension: 0.25,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: "#cbd5f5" } } },
            scales: {
              x: { ticks: { color: "#94a3b8" } },
              y: { ticks: { color: "#94a3b8" } },
            },
          },
        });
      }

      async function fetchSummary() {
        try {
          const res = await fetch(summaryUrl, { cache: "no-store" });
          if (!res.ok) throw new Error(`Summary status ${res.status}`);
          const data = await res.json();
          const tenants = (data.tenants || []).filter((tenant) => ALLOWED.has(tenant.tenant));
          updateSummary(tenants);
          updateLastRefresh();
        } catch (err) {
          console.warn("Failed to fetch summary", err);
        }
      }

      function updateSummary(tenants) {
        const filterValue = tenantFilter.value.trim().toLowerCase();
        const filteredTenants = filterValue
          ? tenants.filter((tenant) => tenant.tenant.toLowerCase().includes(filterValue))
          : tenants;
        const totalTenants = tenants.length;
        let totalUrls = 0;
        let success = 0;
        let pending = 0;
        let failed = 0;
        let totalIndexed = 0;

        const queueLabels = [];
        const queueValues = [];

        const rows = filteredTenants
          .map((tenant) => {
            const stats = tenant.crawl?.stats || {};
            const index = tenant.index || {};
            const queue = parseNumber(stats.queue_depth ?? stats.queueDepth ?? 0);
            const ok = parseNumber(stats.metadata_successful ?? 0);
            const pend = parseNumber(stats.metadata_pending ?? 0);
            const fail = parseNumber(stats.failed_url_count ?? 0);
            const total = parseNumber(stats.metadata_total_urls ?? 0);
            const indexedDocs = parseNumber(index.doc_count ?? 0);
            totalUrls += total;
            success += ok;
            pending += pend;
            failed += fail;
            totalIndexed += indexedDocs;

            queueLabels.push(tenant.tenant);
            queueValues.push(queue);

            return { tenant: tenant.tenant, queue, ok, fail, indexedDocs };
          })
          .sort((a, b) => b.queue - a.queue);

        setText("metric-tenants", fmt(totalTenants));
        setText("metric-urls", fmt(totalUrls));
        setText("metric-success", fmt(success));
        setText("metric-fail", fmt(failed));
        setText("metric-indexed", fmt(totalIndexed));

        summaryChart.data.datasets[0].data = [success, pending, failed];
        summaryChart.update();

        queueChart.data.labels = queueLabels;
        queueChart.data.datasets[0].data = queueValues;
        queueChart.update();

        const tbody = byId("tenant-rows");
        tbody.innerHTML = "";
        rows.forEach((row) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="py-2 text-slate-200">
              <a class="text-cyan-300 hover:text-cyan-200" href="${tenantDashboardUrl(row.tenant)}">${row.tenant}</a>
            </td>
            <td class="py-2 text-right">${fmt(row.queue)}</td>
            <td class="py-2 text-right text-cyan-300">${fmt(row.ok)}</td>
            <td class="py-2 text-right text-rose-300">${fmt(row.fail)}</td>
            <td class="py-2 text-right">${fmt(row.indexedDocs)}</td>
          `;
          tbody.appendChild(tr);
        });
      }

      async function fetchTenant() {
        const tenant = tenantSelect.value;
        if (!tenant) return;
        try {
          const res = await fetch(tenantUrl(tenant), { cache: "no-store" });
          if (!res.ok) throw new Error(`Tenant status ${res.status}`);
          const data = await res.json();
          updateTenant(data);
        } catch (err) {
          console.warn("Failed to fetch tenant", err);
        }
      }

      function updateTenant(payload) {
        const stats = payload.stats || {};
        const index = payload.index || {};
        const queue = parseNumber(stats.queue_depth ?? 0);
        const ok = parseNumber(stats.metadata_successful ?? 0);
        const fail = parseNumber(stats.failed_url_count ?? 0);
        const indexedDocs = parseNumber(index.doc_count ?? 0);

        setText("tenant-queue", fmt(queue));
        setText("tenant-success", fmt(ok));
        setText("tenant-fail", fmt(fail));
        setText("tenant-indexed", fmt(indexedDocs));
        setText("tenant-indexed-at", index.last_indexed_at ? formatTimestamp(index.last_indexed_at) : "n/a");

        tenantHistory.push({ t: new Date().toLocaleTimeString(), queue });
        if (tenantHistory.length > maxHistory) tenantHistory.shift();

        tenantChart.data.labels = tenantHistory.map((point) => point.t);
        tenantChart.data.datasets[0].data = tenantHistory.map((point) => point.queue);
        tenantChart.update();
      }

      function updateUrl(params) {
        const query = params.toString();
        const next = query ? `?${query}` : window.location.pathname;
        window.history.replaceState({}, "", next);
      }

      tenantSelect.addEventListener("change", () => {
        urlParams.set("focus", tenantSelect.value);
        updateUrl(urlParams);
        tenantHistory.length = 0;
        fetchTenant();
      });

      tenantFilter.addEventListener("input", () => {
        const filterValue = tenantFilter.value.trim().toLowerCase();
        const filtered = filterValue
          ? allTenants.filter((tenant) => tenant.toLowerCase().includes(filterValue))
          : allTenants;
        renderTenantSelect(filtered, tenantSelect.value);
        if (filterValue) {
          urlParams.set("filter", filterValue);
        } else {
          urlParams.delete("filter");
        }
        updateUrl(urlParams);
        fetchSummary();
        fetchTenant();
      });

      byId("refresh-now").addEventListener("click", () => {
        fetchSummary();
        fetchTenant();
      });

      byId("go-tenant").addEventListener("click", () => {
        const tenant = tenantSelect.value;
        if (tenant) {
          window.location.href = tenantDashboardUrl(tenant);
        }
      });

      async function triggerSync(force) {
        const tenant = tenantSelect.value;
        if (!tenant) return;
        try {
          const res = await fetch(triggerUrl(tenant, force), { method: "POST" });
          if (!res.ok) throw new Error(`Trigger failed ${res.status}`);
          const data = await res.json();
          alert(data.message || "Sync triggered");
        } catch (err) {
          console.warn("Failed to trigger sync", err);
          alert("Failed to trigger sync");
        }
      }

      byId("trigger-sync").addEventListener("click", () => triggerSync(false));
      byId("force-sync").addEventListener("click", () => triggerSync(true));
      byId("retry-failed").addEventListener("click", async () => {
        const tenant = tenantSelect.value;
        if (!tenant) return;
        try {
          const res = await fetch(retryFailedUrl(tenant), { method: "POST" });
          if (!res.ok) throw new Error(`Retry failed trigger ${res.status}`);
          const data = await res.json();
          alert(data.message || "Retry failed triggered");
        } catch (err) {
          console.warn("Failed to retry failed URLs", err);
          alert("Failed to retry failed URLs");
        }
      });
      byId("trigger-index").addEventListener("click", async () => {
        const tenant = tenantSelect.value;
        if (!tenant) return;
        try {
          const res = await fetch(indexTriggerUrl(tenant, true), { method: "POST" });
          if (!res.ok) throw new Error(`Index trigger failed ${res.status}`);
          const data = await res.json();
          alert(data.message || "Index rebuild triggered");
        } catch (err) {
          console.warn("Failed to trigger index rebuild", err);
          alert("Failed to trigger index rebuild");
        }
      });

      initCharts();
      fetchSummary();
      fetchTenant();
      setInterval(fetchSummary, 60000);
      setInterval(fetchTenant, 7000);
    </script>
{% endblock %}
